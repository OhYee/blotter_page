{"ast":null,"code":"var _regeneratorRuntime = require(\"/github/workspace/node_modules/next/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/github/workspace/node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/github/workspace/node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/github/workspace/node_modules/next/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/github/workspace/node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nmodule.exports = function wasm() {\n  // Copyright 2018 The Go Authors. All rights reserved.\n  // Use of this source code is governed by a BSD-style\n  // license that can be found in the LICENSE file.\n  // Map multiple JavaScript environments to a single common API,\n  // preferring web standards over Node.js API.\n  //\n  // Environments considered:\n  // - Browsers\n  // - Node.js\n  // - Electron\n  // - Parcel\n  if (typeof global !== 'undefined') {// global already exists\n  } else if (true) {\n    window.global = window;\n  } else if (typeof self !== 'undefined') {\n    self.global = self;\n  } else {\n    throw new Error('cannot export Go (neither global, window nor self is defined)');\n  }\n\n  if (!global.require && typeof require !== 'undefined') {\n    global.require = require;\n  } //   if (!global.fs && global.require) {\n  //     global.fs = require('fs');\n  //   }\n\n\n  var enosys = function enosys() {\n    var err = new Error('not implemented');\n    err.code = 'ENOSYS';\n    return err;\n  };\n\n  if (!global.fs) {\n    var outputBuf = '';\n    global.fs = {\n      constants: {\n        O_WRONLY: -1,\n        O_RDWR: -1,\n        O_CREAT: -1,\n        O_TRUNC: -1,\n        O_APPEND: -1,\n        O_EXCL: -1\n      },\n      // unused\n      writeSync: function writeSync(fd, buf) {\n        outputBuf += decoder.decode(buf);\n        var nl = outputBuf.lastIndexOf('\\n');\n\n        if (nl != -1) {\n          console.log(outputBuf.substr(0, nl));\n          outputBuf = outputBuf.substr(nl + 1);\n        }\n\n        return buf.length;\n      },\n      write: function write(fd, buf, offset, length, position, callback) {\n        if (offset !== 0 || length !== buf.length || position !== null) {\n          callback(enosys());\n          return;\n        }\n\n        var n = this.writeSync(fd, buf);\n        callback(null, n);\n      },\n      chmod: function chmod(path, mode, callback) {\n        callback(enosys());\n      },\n      chown: function chown(path, uid, gid, callback) {\n        callback(enosys());\n      },\n      close: function close(fd, callback) {\n        callback(enosys());\n      },\n      fchmod: function fchmod(fd, mode, callback) {\n        callback(enosys());\n      },\n      fchown: function fchown(fd, uid, gid, callback) {\n        callback(enosys());\n      },\n      fstat: function fstat(fd, callback) {\n        callback(enosys());\n      },\n      fsync: function fsync(fd, callback) {\n        callback(null);\n      },\n      ftruncate: function ftruncate(fd, length, callback) {\n        callback(enosys());\n      },\n      lchown: function lchown(path, uid, gid, callback) {\n        callback(enosys());\n      },\n      link: function link(path, _link, callback) {\n        callback(enosys());\n      },\n      lstat: function lstat(path, callback) {\n        callback(enosys());\n      },\n      mkdir: function mkdir(path, perm, callback) {\n        callback(enosys());\n      },\n      open: function open(path, flags, mode, callback) {\n        callback(enosys());\n      },\n      read: function read(fd, buffer, offset, length, position, callback) {\n        callback(enosys());\n      },\n      readdir: function readdir(path, callback) {\n        callback(enosys());\n      },\n      readlink: function readlink(path, callback) {\n        callback(enosys());\n      },\n      rename: function rename(from, to, callback) {\n        callback(enosys());\n      },\n      rmdir: function rmdir(path, callback) {\n        callback(enosys());\n      },\n      stat: function stat(path, callback) {\n        callback(enosys());\n      },\n      symlink: function symlink(path, link, callback) {\n        callback(enosys());\n      },\n      truncate: function truncate(path, length, callback) {\n        callback(enosys());\n      },\n      unlink: function unlink(path, callback) {\n        callback(enosys());\n      },\n      utimes: function utimes(path, atime, mtime, callback) {\n        callback(enosys());\n      }\n    };\n  }\n\n  if (!global.process) {\n    global.process = {\n      getuid: function getuid() {\n        return -1;\n      },\n      getgid: function getgid() {\n        return -1;\n      },\n      geteuid: function geteuid() {\n        return -1;\n      },\n      getegid: function getegid() {\n        return -1;\n      },\n      getgroups: function getgroups() {\n        throw enosys();\n      },\n      pid: -1,\n      ppid: -1,\n      umask: function umask() {\n        throw enosys();\n      },\n      cwd: function cwd() {\n        throw enosys();\n      },\n      chdir: function chdir() {\n        throw enosys();\n      }\n    };\n  }\n\n  if (!global.crypto) {\n    var nodeCrypto = require('crypto');\n\n    global.crypto = {\n      getRandomValues: function getRandomValues(b) {\n        nodeCrypto.randomFillSync(b);\n      }\n    };\n  }\n\n  if (!global.performance) {\n    global.performance = {\n      now: function now() {\n        var _process$hrtime = process.hrtime(),\n            _process$hrtime2 = _slicedToArray(_process$hrtime, 2),\n            sec = _process$hrtime2[0],\n            nsec = _process$hrtime2[1];\n\n        return sec * 1000 + nsec / 1000000;\n      }\n    };\n  }\n\n  if (!global.TextEncoder) {\n    global.TextEncoder = require('util').TextEncoder;\n  }\n\n  if (!global.TextDecoder) {\n    global.TextDecoder = require('util').TextDecoder;\n  } // End of polyfills for common API.\n\n\n  var encoder = new TextEncoder('utf-8');\n  var decoder = new TextDecoder('utf-8');\n\n  global.Go = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _class() {\n      var _this = this;\n\n      _classCallCheck(this, _class);\n\n      this.argv = ['js'];\n      this.env = {};\n\n      this.exit = function (code) {\n        if (code !== 0) {\n          console.warn('exit code:', code);\n        }\n      };\n\n      this._exitPromise = new Promise(function (resolve) {\n        _this._resolveExitPromise = resolve;\n      });\n      this._pendingEvent = null;\n      this._scheduledTimeouts = new Map();\n      this._nextCallbackTimeoutID = 1;\n\n      var setInt64 = function setInt64(addr, v) {\n        _this.mem.setUint32(addr + 0, v, true);\n\n        _this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n      };\n\n      var getInt64 = function getInt64(addr) {\n        var low = _this.mem.getUint32(addr + 0, true);\n\n        var high = _this.mem.getInt32(addr + 4, true);\n\n        return low + high * 4294967296;\n      };\n\n      var loadValue = function loadValue(addr) {\n        var f = _this.mem.getFloat64(addr, true);\n\n        if (f === 0) {\n          return undefined;\n        }\n\n        if (!isNaN(f)) {\n          return f;\n        }\n\n        var id = _this.mem.getUint32(addr, true);\n\n        return _this._values[id];\n      };\n\n      var storeValue = function storeValue(addr, v) {\n        var nanHead = 0x7ff80000;\n\n        if (typeof v === 'number') {\n          if (isNaN(v)) {\n            _this.mem.setUint32(addr + 4, nanHead, true);\n\n            _this.mem.setUint32(addr, 0, true);\n\n            return;\n          }\n\n          if (v === 0) {\n            _this.mem.setUint32(addr + 4, nanHead, true);\n\n            _this.mem.setUint32(addr, 1, true);\n\n            return;\n          }\n\n          _this.mem.setFloat64(addr, v, true);\n\n          return;\n        }\n\n        switch (v) {\n          case undefined:\n            _this.mem.setFloat64(addr, 0, true);\n\n            return;\n\n          case null:\n            _this.mem.setUint32(addr + 4, nanHead, true);\n\n            _this.mem.setUint32(addr, 2, true);\n\n            return;\n\n          case true:\n            _this.mem.setUint32(addr + 4, nanHead, true);\n\n            _this.mem.setUint32(addr, 3, true);\n\n            return;\n\n          case false:\n            _this.mem.setUint32(addr + 4, nanHead, true);\n\n            _this.mem.setUint32(addr, 4, true);\n\n            return;\n        }\n\n        var id = _this._ids.get(v);\n\n        if (id === undefined) {\n          id = _this._idPool.pop();\n\n          if (id === undefined) {\n            id = _this._values.length;\n          }\n\n          _this._values[id] = v;\n          _this._goRefCounts[id] = 0;\n\n          _this._ids.set(v, id);\n        }\n\n        _this._goRefCounts[id]++;\n        var typeFlag = 1;\n\n        switch (typeof v) {\n          case 'string':\n            typeFlag = 2;\n            break;\n\n          case 'symbol':\n            typeFlag = 3;\n            break;\n\n          case 'function':\n            typeFlag = 4;\n            break;\n        }\n\n        _this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n\n        _this.mem.setUint32(addr, id, true);\n      };\n\n      var loadSlice = function loadSlice(addr) {\n        var array = getInt64(addr + 0);\n        var len = getInt64(addr + 8);\n        return new Uint8Array(_this._inst.exports.mem.buffer, array, len);\n      };\n\n      var loadSliceOfValues = function loadSliceOfValues(addr) {\n        var array = getInt64(addr + 0);\n        var len = getInt64(addr + 8);\n        var a = new Array(len);\n\n        for (var i = 0; i < len; i++) {\n          a[i] = loadValue(array + i * 8);\n        }\n\n        return a;\n      };\n\n      var loadString = function loadString(addr) {\n        var saddr = getInt64(addr + 0);\n        var len = getInt64(addr + 8);\n        return decoder.decode(new DataView(_this._inst.exports.mem.buffer, saddr, len));\n      };\n\n      var timeOrigin = Date.now() - performance.now();\n      this.importObject = {\n        go: {\n          // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n          // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n          // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n          // This changes the SP, thus we have to update the SP used by the imported function.\n          // func wasmExit(code int32)\n          'runtime.wasmExit': function runtimeWasmExit(sp) {\n            var code = _this.mem.getInt32(sp + 8, true);\n\n            _this.exited = true;\n            delete _this._inst;\n            delete _this._values;\n            delete _this._goRefCounts;\n            delete _this._ids;\n            delete _this._idPool;\n\n            _this.exit(code);\n          },\n          // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n          'runtime.wasmWrite': function runtimeWasmWrite(sp) {\n            var fd = getInt64(sp + 8);\n            var p = getInt64(sp + 16);\n\n            var n = _this.mem.getInt32(sp + 24, true);\n\n            fs.writeSync(fd, new Uint8Array(_this._inst.exports.mem.buffer, p, n));\n          },\n          // func resetMemoryDataView()\n          'runtime.resetMemoryDataView': function runtimeResetMemoryDataView(sp) {\n            _this.mem = new DataView(_this._inst.exports.mem.buffer);\n          },\n          // func nanotime1() int64\n          'runtime.nanotime1': function runtimeNanotime1(sp) {\n            setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n          },\n          // func walltime1() (sec int64, nsec int32)\n          'runtime.walltime1': function runtimeWalltime1(sp) {\n            var msec = new Date().getTime();\n            setInt64(sp + 8, msec / 1000);\n\n            _this.mem.setInt32(sp + 16, msec % 1000 * 1000000, true);\n          },\n          // func scheduleTimeoutEvent(delay int64) int32\n          'runtime.scheduleTimeoutEvent': function runtimeScheduleTimeoutEvent(sp) {\n            var id = _this._nextCallbackTimeoutID;\n            _this._nextCallbackTimeoutID++;\n\n            _this._scheduledTimeouts.set(id, setTimeout(function () {\n              _this._resume();\n\n              while (_this._scheduledTimeouts.has(id)) {\n                // for some reason Go failed to register the timeout event, log and try again\n                // (temporary workaround for https://github.com/golang/go/issues/28975)\n                console.warn('scheduleTimeoutEvent: missed timeout event');\n\n                _this._resume();\n              }\n            }, getInt64(sp + 8) + 1 // setTimeout has been seen to fire up to 1 millisecond early\n            ));\n\n            _this.mem.setInt32(sp + 16, id, true);\n          },\n          // func clearTimeoutEvent(id int32)\n          'runtime.clearTimeoutEvent': function runtimeClearTimeoutEvent(sp) {\n            var id = _this.mem.getInt32(sp + 8, true);\n\n            clearTimeout(_this._scheduledTimeouts.get(id));\n\n            _this._scheduledTimeouts[\"delete\"](id);\n          },\n          // func getRandomData(r []byte)\n          'runtime.getRandomData': function runtimeGetRandomData(sp) {\n            crypto.getRandomValues(loadSlice(sp + 8));\n          },\n          // func finalizeRef(v ref)\n          'syscall/js.finalizeRef': function syscallJsFinalizeRef(sp) {\n            var id = _this.mem.getUint32(sp + 8, true);\n\n            _this._goRefCounts[id]--;\n\n            if (_this._goRefCounts[id] === 0) {\n              var v = _this._values[id];\n              _this._values[id] = null;\n\n              _this._ids[\"delete\"](v);\n\n              _this._idPool.push(id);\n            }\n          },\n          // func stringVal(value string) ref\n          'syscall/js.stringVal': function syscallJsStringVal(sp) {\n            storeValue(sp + 24, loadString(sp + 8));\n          },\n          // func valueGet(v ref, p string) ref\n          'syscall/js.valueGet': function syscallJsValueGet(sp) {\n            var result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n            sp = _this._inst.exports.getsp(); // see comment above\n\n            storeValue(sp + 32, result);\n          },\n          // func valueSet(v ref, p string, x ref)\n          'syscall/js.valueSet': function syscallJsValueSet(sp) {\n            Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n          },\n          // func valueDelete(v ref, p string)\n          'syscall/js.valueDelete': function syscallJsValueDelete(sp) {\n            Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n          },\n          // func valueIndex(v ref, i int) ref\n          'syscall/js.valueIndex': function syscallJsValueIndex(sp) {\n            storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n          },\n          // valueSetIndex(v ref, i int, x ref)\n          'syscall/js.valueSetIndex': function syscallJsValueSetIndex(sp) {\n            Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n          },\n          // func valueCall(v ref, m string, args []ref) (ref, bool)\n          'syscall/js.valueCall': function syscallJsValueCall(sp) {\n            try {\n              var v = loadValue(sp + 8);\n              var m = Reflect.get(v, loadString(sp + 16));\n              var args = loadSliceOfValues(sp + 32);\n              var result = Reflect.apply(m, v, args);\n              sp = _this._inst.exports.getsp(); // see comment above\n\n              storeValue(sp + 56, result);\n\n              _this.mem.setUint8(sp + 64, 1);\n            } catch (err) {\n              storeValue(sp + 56, err);\n\n              _this.mem.setUint8(sp + 64, 0);\n            }\n          },\n          // func valueInvoke(v ref, args []ref) (ref, bool)\n          'syscall/js.valueInvoke': function syscallJsValueInvoke(sp) {\n            try {\n              var v = loadValue(sp + 8);\n              var args = loadSliceOfValues(sp + 16);\n              var result = Reflect.apply(v, undefined, args);\n              sp = _this._inst.exports.getsp(); // see comment above\n\n              storeValue(sp + 40, result);\n\n              _this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              storeValue(sp + 40, err);\n\n              _this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueNew(v ref, args []ref) (ref, bool)\n          'syscall/js.valueNew': function syscallJsValueNew(sp) {\n            try {\n              var v = loadValue(sp + 8);\n              var args = loadSliceOfValues(sp + 16);\n              var result = Reflect.construct(v, args);\n              sp = _this._inst.exports.getsp(); // see comment above\n\n              storeValue(sp + 40, result);\n\n              _this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              storeValue(sp + 40, err);\n\n              _this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueLength(v ref) int\n          'syscall/js.valueLength': function syscallJsValueLength(sp) {\n            setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n          },\n          // valuePrepareString(v ref) (ref, int)\n          'syscall/js.valuePrepareString': function syscallJsValuePrepareString(sp) {\n            var str = encoder.encode(String(loadValue(sp + 8)));\n            storeValue(sp + 16, str);\n            setInt64(sp + 24, str.length);\n          },\n          // valueLoadString(v ref, b []byte)\n          'syscall/js.valueLoadString': function syscallJsValueLoadString(sp) {\n            var str = loadValue(sp + 8);\n            loadSlice(sp + 16).set(str);\n          },\n          // func valueInstanceOf(v ref, t ref) bool\n          'syscall/js.valueInstanceOf': function syscallJsValueInstanceOf(sp) {\n            _this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16));\n          },\n          // func copyBytesToGo(dst []byte, src ref) (int, bool)\n          'syscall/js.copyBytesToGo': function syscallJsCopyBytesToGo(sp) {\n            var dst = loadSlice(sp + 8);\n            var src = loadValue(sp + 32);\n\n            if (!(src instanceof Uint8Array)) {\n              _this.mem.setUint8(sp + 48, 0);\n\n              return;\n            }\n\n            var toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n\n            _this.mem.setUint8(sp + 48, 1);\n          },\n          // func copyBytesToJS(dst ref, src []byte) (int, bool)\n          'syscall/js.copyBytesToJS': function syscallJsCopyBytesToJS(sp) {\n            var dst = loadValue(sp + 8);\n            var src = loadSlice(sp + 16);\n\n            if (!(dst instanceof Uint8Array)) {\n              _this.mem.setUint8(sp + 48, 0);\n\n              return;\n            }\n\n            var toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n\n            _this.mem.setUint8(sp + 48, 1);\n          },\n          debug: function debug(value) {\n            console.log(value);\n          }\n        }\n      };\n    }\n\n    _createClass(_class, [{\n      key: \"run\",\n      value: function () {\n        var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(instance) {\n          var _this2 = this;\n\n          var offset, strPtr, argc, argvPtrs, keys, argv;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  this._inst = instance;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                  this._values = [// JS values that Go currently has references to, indexed by reference id\n                  NaN, 0, null, true, false, global, this];\n                  this._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id\n\n                  this._ids = new Map(); // mapping from JS values to reference ids\n\n                  this._idPool = []; // unused ids that have been garbage collected\n\n                  this.exited = false; // whether the Go program has exited\n                  // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\n                  offset = 4096;\n\n                  strPtr = function strPtr(str) {\n                    var ptr = offset;\n                    var bytes = encoder.encode(str + '\\0');\n                    new Uint8Array(_this2.mem.buffer, offset, bytes.length).set(bytes);\n                    offset += bytes.length;\n\n                    if (offset % 8 !== 0) {\n                      offset += 8 - offset % 8;\n                    }\n\n                    return ptr;\n                  };\n\n                  argc = this.argv.length;\n                  argvPtrs = [];\n                  this.argv.forEach(function (arg) {\n                    argvPtrs.push(strPtr(arg));\n                  });\n                  argvPtrs.push(0);\n                  keys = Object.keys(this.env).sort();\n                  keys.forEach(function (key) {\n                    argvPtrs.push(strPtr(\"\".concat(key, \"=\").concat(_this2.env[key])));\n                  });\n                  argvPtrs.push(0);\n                  argv = offset;\n                  argvPtrs.forEach(function (ptr) {\n                    _this2.mem.setUint32(offset, ptr, true);\n\n                    _this2.mem.setUint32(offset + 4, 0, true);\n\n                    offset += 8;\n                  });\n\n                  this._inst.exports.run(argc, argv);\n\n                  if (this.exited) {\n                    this._resolveExitPromise();\n                  }\n\n                  _context.next = 22;\n                  return this._exitPromise;\n\n                case 22:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function run(_x) {\n          return _run.apply(this, arguments);\n        }\n\n        return run;\n      }()\n    }, {\n      key: \"_resume\",\n      value: function _resume() {\n        if (this.exited) {\n          throw new Error('Go program has already exited');\n        }\n\n        this._inst.exports.resume();\n\n        if (this.exited) {\n          this._resolveExitPromise();\n        }\n      }\n    }, {\n      key: \"_makeFuncWrapper\",\n      value: function _makeFuncWrapper(id) {\n        var go = this;\n        return function () {\n          var event = {\n            id: id,\n            \"this\": this,\n            args: arguments\n          };\n          go._pendingEvent = event;\n\n          go._resume();\n\n          return event.result;\n        };\n      }\n    }]);\n\n    return _class;\n  }();\n\n  if (global.require && global.require.main === module && global.process && global.process.versions && !global.process.versions.electron) {\n    if (process.argv.length < 3) {\n      console.error('usage: go_js_wasm_exec [wasm binary] [arguments]');\n      process.exit(1);\n    }\n\n    var go = new Go();\n    go.argv = process.argv.slice(2);\n    go.env = Object.assign({\n      TMPDIR: require('os').tmpdir()\n    }, process.env);\n    go.exit = process.exit;\n    WebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then(function (result) {\n      process.on('exit', function (code) {\n        // Node.js exits if no event handler is pending\n        if (code === 0 && !go.exited) {\n          // deadlock, make Go print error and stack traces\n          go._pendingEvent = {\n            id: 0\n          };\n\n          go._resume();\n        }\n      });\n      return go.run(result.instance);\n    })[\"catch\"](function (err) {\n      console.error(err);\n      process.exit(1);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}